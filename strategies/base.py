"""
Base Strategy Class for the Quantitative Trading Strategy Backtester.
Defines the interface that all strategies must implement.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
import pandas as pd
import numpy as np
import logging

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        ticker: Asset ticker symbol
        direction: 1 for long, -1 for short, 0 for flat/exit
        strength: Signal strength from 0 to 1 (for position sizing)
        timestamp: When the signal was generated
        metadata: Additional signal information
    """
    ticker: str
    direction: int  # 1 = long, -1 = short, 0 = exit
    strength: float  # 0 to 1
    timestamp: pd.Timestamp
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate signal parameters."""
        if self.direction not in [-1, 0, 1]:
            raise ValueError(f"Direction must be -1, 0, or 1, got {self.direction}")
        if not 0 <= self.strength <= 1:
            raise ValueError(f"Strength must be between 0 and 1, got {self.strength}")


class Strategy(ABC):
    """
    Abstract base class for all trading strategies.

    Strategies generate signals based on market data and defined rules.
    Each strategy must implement the generate_signals method.
    """

    def __init__(self, name: str, params: Optional[Dict[str, Any]] = None):
        """
        Initialize the strategy.

        Args:
            name: Strategy identifier
            params: Strategy-specific parameters
        """
        self.name = name
        self.params = params or {}
        self._signals_history: List[Signal] = []

    @abstractmethod
    def generate_signals(
        self,
        prices: pd.DataFrame,
        current_date: pd.Timestamp,
        positions: Optional[Dict[str, Any]] = None
    ) -> List[Signal]:
        """
        Generate trading signals based on current market data.

        Args:
            prices: DataFrame with asset prices (rows=dates, columns=tickers)
            current_date: Current simulation date
            positions: Current portfolio positions

        Returns:
            List of Signal objects for each recommended action
        """
        pass

    @abstractmethod
    def get_required_history(self) -> int:
        """
        Return the number of historical days required for signal generation.

        Returns:
            Number of days of historical data needed
        """
        pass

    def validate_data(self, prices: pd.DataFrame, min_days: int) -> bool:
        """
        Validate that sufficient data is available.

        Args:
            prices: Price DataFrame
            min_days: Minimum required days

        Returns:
            True if data is sufficient
        """
        if prices.empty:
            logger.warning(f"{self.name}: Empty price data")
            return False

        if len(prices) < min_days:
            logger.warning(f"{self.name}: Insufficient data. Have {len(prices)}, need {min_days}")
            return False

        return True

    def calculate_returns(
        self,
        prices: pd.DataFrame,
        periods: int = 1
    ) -> pd.DataFrame:
        """
        Calculate returns for given period.

        Args:
            prices: Price DataFrame
            periods: Number of periods for return calculation

        Returns:
            Returns DataFrame
        """
        return prices.pct_change(periods=periods)

    def calculate_volatility(
        self,
        returns: pd.DataFrame,
        window: int = 20
    ) -> pd.DataFrame:
        """
        Calculate rolling volatility.

        Args:
            returns: Returns DataFrame
            window: Rolling window size

        Returns:
            Volatility DataFrame
        """
        return returns.rolling(window=window).std()

    def calculate_moving_average(
        self,
        prices: pd.DataFrame,
        window: int
    ) -> pd.DataFrame:
        """
        Calculate simple moving average.

        Args:
            prices: Price DataFrame
            window: MA window size

        Returns:
            Moving average DataFrame
        """
        return prices.rolling(window=window).mean()

    def calculate_exponential_ma(
        self,
        prices: pd.DataFrame,
        span: int
    ) -> pd.DataFrame:
        """
        Calculate exponential moving average.

        Args:
            prices: Price DataFrame
            span: EMA span

        Returns:
            EMA DataFrame
        """
        return prices.ewm(span=span, adjust=False).mean()

    def calculate_zscore(
        self,
        series: pd.Series,
        window: int
    ) -> pd.Series:
        """
        Calculate rolling z-score.

        Args:
            series: Price or returns series
            window: Rolling window size

        Returns:
            Z-score series
        """
        mean = series.rolling(window=window).mean()
        std = series.rolling(window=window).std()
        return (series - mean) / std.replace(0, np.nan)

    def record_signal(self, signal: Signal):
        """Record a signal in history for analysis."""
        self._signals_history.append(signal)

    def get_signals_history(self) -> List[Signal]:
        """Get historical signals."""
        return self._signals_history.copy()

    def clear_history(self):
        """Clear signals history."""
        self._signals_history.clear()

    def get_params(self) -> Dict[str, Any]:
        """Get strategy parameters."""
        return self.params.copy()

    def set_params(self, params: Dict[str, Any]):
        """Update strategy parameters."""
        self.params.update(params)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', params={self.params})"
